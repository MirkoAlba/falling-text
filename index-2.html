<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Falling text</title>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"
      integrity="sha512-6+7rTBmR6pRFe9fa0vCFjFaHZj/XYa7774bEBzRtxgdpIJOS++R3cKd6Prg/eJmxtsJotd8KAg4g57uuVQsZKA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link rel="stylesheet" href="https://use.typekit.net/gwy5vve.css" />

    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="container-boxes" class="container-boxes">
      <div class="box box--green" id="box-0">
        <p>NO WONDER</p>
      </div>
    </div>

    <script>
      function mergeObjects(obj1, obj2) {
        return { ...obj1, ...obj2 };
      }

      var VIEW = {};
      VIEW.width = window.innerWidth;
      VIEW.height = window.innerHeight;
      VIEW.centerX = VIEW.width / 2;
      VIEW.centerY = VIEW.height / 2;
      VIEW.offsetX = VIEW.width / 2;
      VIEW.offsetY = VIEW.height / 2;

      // Matter.js module aliases
      var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Common = Matter.Common,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Body = Matter.Body,
        Events = Matter.Events,
        Query = Matter.Query;

      // create engine
      var engine = Engine.create(),
        world = engine.world;

      // create renderer
      var render = Render.create({
        engine: engine,
        element: document.getElementById("container-boxes"),
        options: {
          width: window.innerWidth,
          height: window.innerHeight,
          background: "#f2f2f2",
          wireframeBackground: false,
          hasBounds: true,
          enabled: true,
          wireframes: true,
          showSleeping: true,
          showDebug: true,
          showBroadphase: true,
          showBounds: true,
          showVelocity: true,
          showCollisions: true,
          showAxes: false,
          showPositions: true,
          showAngleIndicator: true,
          showIds: true,
          showShadows: false,
        },
      });

      Render.run(render);

      // create runner
      var runner = Runner.create();
      Runner.run(runner, engine);

      var wallLeft, wallRight, ground;

      // add walls
      var wallopts = {
        isStatic: true,
        restitution: 0.8,
        friction: 1,
      };

      var groundopts = {
        isStatic: true,
        restitution: 0.8,
        friction: 1,
      };

      World.add(world, [
        // ground
        (ground = Bodies.rectangle(
          window.innerWidth / 2,
          window.innerHeight + 50,
          window.innerWidth + 200,
          100,
          groundopts
        )),
        // walls
        (wallRight = Bodies.rectangle(
          window.innerWidth + 50,
          window.innerHeight / 2,
          100,
          window.innerHeight,
          wallopts
        )), // right
        (wallLeft = Bodies.rectangle(
          -50,
          window.innerHeight / 2,
          100,
          window.innerHeight,
          wallopts
        )), // left
      ]);

      // Boxes
      var defaultBoxOpts = {
        restitution: 0.5,
        friction: 0,
        frictionAir: 0.001,
        frictionStatic: 0,
        density: 1,
      };

      var pixelStartingPoint = -VIEW.height;

      var bodiesDom = document.querySelectorAll(".box"),
        bodies = [];

      // Init the bodies
      for (var i = 0, l = bodiesDom.length; i < l; i++) {
        var bodyDomPosition = bodiesDom[i].getBoundingClientRect(),
          bodyDomWidth = bodyDomPosition.width,
          boxDomHeight = bodyDomPosition.height;

        var borderRadius = parseFloat(
          window.getComputedStyle(bodiesDom[i]).borderRadius
        );

        console.log(borderRadius);

        var body = Bodies.rectangle(
          VIEW.centerX + Math.floor(VIEW.width / 2) - VIEW.width / 4,
          VIEW.centerY + Math.floor(VIEW.height / 2) - VIEW.height / 4,
          bodyDomWidth,
          boxDomHeight,
          mergeObjects(defaultBoxOpts, {
            chamfer: { radius: borderRadius },
          })
        );

        bodiesDom[i].id = body.id;

        bodies.push(body);
      }

      World.add(engine.world, bodies);

      engine.world.gravity.y = 1;

      (function update() {
        // strips
        for (var i = 0, l = bodiesDom.length; i < l; i++) {
          var bodyDom = bodiesDom[i],
            body = null;

          for (var j = 0, k = bodies.length; j < k; j++) {
            if (bodies[j].id == bodyDom.id) {
              body = bodies[j];
              break;
            }
          }

          if (body === null) continue;

          bodyDom.style.transform =
            "translate( " +
            (body.position.x - bodyDom.offsetWidth / 2) +
            "px, " +
            (body.position.y - bodyDom.offsetHeight / 2) +
            "px )";
          bodyDom.style.transform += "rotate( " + body.angle + "rad )";
        }

        Engine.update(engine);

        window.requestAnimationFrame(update);
      })();

      //   (function rerender() {
      //     window.requestAnimationFrame(rerender);

      //     for (let i = 0; i < subSteps; i++) {
      //       boxes.forEach((box) => box.render());

      //       Engine.update(engine, subDelta);
      //     }
      //   })();
    </script>
  </body>
</html>
